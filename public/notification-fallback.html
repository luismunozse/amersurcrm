<!DOCTYPE html>
<html>
<head>
  <title>Generar Sonido de Notificación</title>
</head>
<body>
  <h1>Generar Sonido de Notificación</h1>
  <button onclick="generateSound()">▶️ Reproducir Sonido</button>
  <button onclick="downloadSound()">⬇️ Descargar notification.mp3</button>

  <script>
    let audioContext;
    let buffer;

    function generateSound() {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();

      // Crear un sonido de notificación agradable
      const duration = 0.3;
      const sampleRate = audioContext.sampleRate;
      buffer = audioContext.createBuffer(1, duration * sampleRate, sampleRate);
      const data = buffer.getChannelData(0);

      // Generar tono con envelope
      for (let i = 0; i < buffer.length; i++) {
        const t = i / sampleRate;
        const frequency = 800 + (400 * Math.sin(t * 20)); // Frecuencia modulada
        const envelope = Math.exp(-t * 8); // Decay exponencial
        data[i] = Math.sin(2 * Math.PI * frequency * t) * envelope * 0.3;
      }

      // Reproducir
      const source = audioContext.createBufferSource();
      source.buffer = buffer;
      source.connect(audioContext.destination);
      source.start();
    }

    function downloadSound() {
      if (!buffer) {
        generateSound();
        setTimeout(downloadSound, 500);
        return;
      }

      // Convertir a WAV
      const wav = bufferToWave(buffer, buffer.length);
      const blob = new Blob([wav], { type: 'audio/wav' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = 'notification.wav';
      a.click();

      alert('Descarga iniciada. Renombra el archivo a notification.mp3 y colócalo en la carpeta /public/');
    }

    function bufferToWave(abuffer, len) {
      const numOfChan = abuffer.numberOfChannels;
      const length = len * numOfChan * 2 + 44;
      const buffer = new ArrayBuffer(length);
      const view = new DataView(buffer);
      const channels = [];
      let sample;
      let offset = 0;
      let pos = 0;

      // Write WAVE header
      setUint32(0x46464952); // "RIFF"
      setUint32(length - 8); // file length - 8
      setUint32(0x45564157); // "WAVE"
      setUint32(0x20746d66); // "fmt " chunk
      setUint32(16); // length = 16
      setUint16(1); // PCM (uncompressed)
      setUint16(numOfChan);
      setUint32(abuffer.sampleRate);
      setUint32(abuffer.sampleRate * 2 * numOfChan); // avg. bytes/sec
      setUint16(numOfChan * 2); // block-align
      setUint16(16); // 16-bit
      setUint32(0x61746164); // "data" - chunk
      setUint32(length - pos - 4); // chunk length

      // Write interleaved data
      for (let i = 0; i < abuffer.numberOfChannels; i++)
        channels.push(abuffer.getChannelData(i));

      while (pos < length) {
        for (let i = 0; i < numOfChan; i++) {
          sample = Math.max(-1, Math.min(1, channels[i][offset]));
          sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0;
          view.setInt16(pos, sample, true);
          pos += 2;
        }
        offset++;
      }

      return buffer;

      function setUint16(data) {
        view.setUint16(pos, data, true);
        pos += 2;
      }

      function setUint32(data) {
        view.setUint32(pos, data, true);
        pos += 4;
      }
    }
  </script>
</body>
</html>
